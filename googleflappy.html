<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy to Runner Evolution</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #333;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace;
            overflow: hidden;
        }
        canvas {
            background-color: #70c5ce; /* Sky blue */
            border: 4px solid #fff;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            max-width: 100%;
            max-height: 100%;
        }
        #instructions {
            position: absolute;
            top: 10px;
            color: white;
            text-align: center;
            pointer-events: none;
        }
    </style>
</head>
<body>

    <div id="instructions">
        <h3>Phase 1: Flap (Click/Space) to 15</h3>
        <h3>Phase 2: Run & Jump to 30</h3>
    </div>
    <canvas id="gameCanvas" width="480" height="640"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    // --- GAME VARIABLES ---
    let frames = 0;
    let score = 0;
    let highScore = 0;
    
    // Game States: START, FLAPPY, RUNNER, GAMEOVER, WIN
    let currentState = 'START';

    // Physics
    const GRAVITY = 0.25;      // Low gravity for "Easy" feel
    const FLAP_STRENGTH = -5.5; 
    const RUNNER_JUMP = -8;
    const GAME_SPEED = 3; 

    // --- ASSETS / OBJECTS ---

    const bird = {
        x: 50,
        y: 150,
        w: 30,
        h: 30,
        velocity: 0,
        radius: 15,
        
        draw: function() {
            ctx.fillStyle = '#ffcc00'; // Yellow
            
            // Draw Body
            ctx.beginPath();
            ctx.rect(this.x, this.y, this.w, this.h);
            ctx.fill();
            ctx.lineWidth = 2;
            ctx.strokeStyle = '#000';
            ctx.stroke();

            // Draw Eye
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.arc(this.x + 22, this.y + 8, 5, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.beginPath();
            ctx.arc(this.x + 24, this.y + 8, 2, 0, Math.PI * 2);
            ctx.fill();

            // Draw Legs if in RUNNER mode
            if (currentState === 'RUNNER' || currentState === 'WIN') {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 3;
                
                // Simple animation for running legs
                let legOffset = Math.sin(frames * 0.2) * 10;
                
                // Left Leg
                ctx.beginPath();
                ctx.moveTo(this.x + 5, this.y + this.h);
                ctx.lineTo(this.x + 5 - legOffset, this.y + this.h + 15);
                ctx.stroke();

                // Right Leg
                ctx.beginPath();
                ctx.moveTo(this.x + 25, this.y + this.h);
                ctx.lineTo(this.x + 25 + legOffset, this.y + this.h + 15);
                ctx.stroke();
            }
            
            // Draw Wing (visual only)
            ctx.fillStyle = '#fff';
            ctx.beginPath();
            ctx.ellipse(this.x + 10, this.y + 18, 8, 5, 0, 0, Math.PI*2);
            ctx.fill();
            ctx.stroke();
        },

        update: function() {
            // Apply Gravity
            this.velocity += GRAVITY;
            this.y += this.velocity;

            // Ground Collision Logic based on mode
            let groundLevel = canvas.height - ground.h;

            // FLAPPY MODE PHYSICS
            if (currentState === 'FLAPPY') {
                // Hitting the floor
                if (this.y + this.h >= groundLevel) {
                    this.y = groundLevel - this.h;
                    gameOver();
                }
                // Hitting the ceiling
                if (this.y < 0) {
                    this.y = 0;
                    this.velocity = 0;
                }
            } 
            // RUNNER MODE PHYSICS
            else if (currentState === 'RUNNER') {
                // Stay on ground
                if (this.y + this.h >= groundLevel) {
                    this.y = groundLevel - this.h;
                    this.velocity = 0; // Reset velocity when on ground
                }
            }
        },

        flap: function() {
            this.velocity = FLAP_STRENGTH;
        },

        jump: function() {
            let groundLevel = canvas.height - ground.h;
            // Only jump if currently on the ground
            if (this.y + this.h >= groundLevel - 1) {
                this.velocity = RUNNER_JUMP;
            }
        },
        
        reset: function() {
            this.y = 150;
            this.velocity = 0;
        }
    };

    const ground = {
        h: 50,
        draw: function() {
            ctx.fillStyle = '#ded895'; // Sand color
            ctx.fillRect(0, canvas.height - this.h, canvas.width, this.h);
            
            // Top grass line
            ctx.fillStyle = '#73bf2e';
            ctx.fillRect(0, canvas.height - this.h, canvas.width, 10);
        }
    };

    // --- OBSTACLE MANAGEMENT ---
    
    const pipes = {
        items: [],
        w: 50,
        dx: GAME_SPEED,
        gap: 170, // Wide gap for "Easy" mode
        
        draw: function() {
            for(let i = 0; i < this.items.length; i++) {
                let p = this.items[i];
                ctx.fillStyle = '#73bf2e';
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 2;
                
                // Top Pipe
                ctx.fillRect(p.x, 0, this.w, p.top);
                ctx.strokeRect(p.x, 0, this.w, p.top);
                
                // Bottom Pipe
                ctx.fillRect(p.x, canvas.height - ground.h - p.bottom, this.w, p.bottom);
                ctx.strokeRect(p.x, canvas.height - ground.h - p.bottom, this.w, p.bottom);
            }
        },
        
        update: function() {
            // Add new pipe every 120 frames
            if (frames % 120 === 0) {
                // Calculate random height
                // Available height = Canvas - Ground
                let availableHeight = canvas.height - ground.h;
                let maxPipeHeight = availableHeight - this.gap - 20;
                let topHeight = Math.floor(Math.random() * (maxPipeHeight - 20)) + 20;
                let bottomHeight = availableHeight - this.gap - topHeight;
                
                this.items.push({
                    x: canvas.width,
                    top: topHeight,
                    bottom: bottomHeight,
                    passed: false
                });
            }

            for(let i = 0; i < this.items.length; i++) {
                let p = this.items[i];
                p.x -= this.dx;

                // Collision Detection
                if (
                    bird.x + bird.w > p.x && 
                    bird.x < p.x + this.w && 
                    (bird.y < p.top || bird.y + bird.h > canvas.height - ground.h - p.bottom)
                ) {
                    gameOver();
                }

                // Scoring
                if (p.x + this.w < bird.x && !p.passed) {
                    score++;
                    p.passed = true;
                    checkPhaseTransition();
                }

                // Remove off-screen pipes
                if (p.x + this.w < 0) {
                    this.items.shift();
                    i--;
                }
            }
        },
        
        reset: function() {
            this.items = [];
        }
    };

    const runnerBlocks = {
        items: [],
        w: 30,
        h: 50,
        dx: GAME_SPEED,

        draw: function() {
            for(let i = 0; i < this.items.length; i++) {
                let b = this.items[i];
                ctx.fillStyle = '#e74c3c'; // Red block
                ctx.strokeStyle = '#000';
                
                let yPos = canvas.height - ground.h - this.h;
                
                ctx.fillRect(b.x, yPos, this.w, this.h);
                ctx.strokeRect(b.x, yPos, this.w, this.h);
                
                // Draw "spikes" or detail on block
                ctx.beginPath();
                ctx.moveTo(b.x, yPos);
                ctx.lineTo(b.x + this.w, yPos + this.h);
                ctx.stroke();
            }
        },

        update: function() {
            // Spawn blocks more frequently than pipes
            if (frames % 100 === 0) {
                this.items.push({
                    x: canvas.width,
                    passed: false
                });
            }

            for(let i = 0; i < this.items.length; i++) {
                let b = this.items[i];
                b.x -= this.dx;

                let blockY = canvas.height - ground.h - this.h;

                // Collision Detection (Simple AABB)
                if (
                    bird.x < b.x + this.w &&
                    bird.x + bird.w > b.x &&
                    bird.y + bird.h > blockY
                ) {
                    gameOver();
                }

                // Scoring
                if (b.x + this.w < bird.x && !b.passed) {
                    score++;
                    b.passed = true;
                    checkWinCondition();
                }

                if (b.x + this.w < 0) {
                    this.items.shift();
                    i--;
                }
            }
        },
        
        reset: function() {
            this.items = [];
        }
    };

    // --- GAME LOGIC ---

    function checkPhaseTransition() {
        if (score === 15) {
            transitionToRunner();
        }
    }

    function checkWinCondition() {
        if (score >= 30) {
            currentState = 'WIN';
        }
    }

    function transitionToRunner() {
        currentState = 'RUNNER';
        // Clear pipes
        pipes.reset();
        // Teleport bird to ground safely
        bird.y = canvas.height - ground.h - bird.h;
        bird.velocity = 0;
    }

    function gameOver() {
        currentState = 'GAMEOVER';
        if (score > highScore) highScore = score;
    }

    function resetGame() {
        bird.reset();
        pipes.reset();
        runnerBlocks.reset();
        score = 0;
        frames = 0;
        currentState = 'START';
    }

    function drawScore() {
        ctx.fillStyle = '#FFF';
        ctx.strokeStyle = '#000';
        ctx.lineWidth = 2;
        ctx.font = "35px Courier New";
        ctx.textAlign = "center";
        ctx.strokeText(score, canvas.width/2, 50);
        ctx.fillText(score, canvas.width/2, 50);
        
        // Mode Indicator
        ctx.font = "16px Courier New";
        let modeText = score < 15 ? "MODE: FLAPPY" : "MODE: RUNNER";
        ctx.fillText(modeText, canvas.width/2, 80);
    }

    function drawUI() {
        if (currentState === 'START') {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = '#FFF';
            ctx.textAlign = "center";
            ctx.font = "30px Courier New";
            ctx.fillText("FLAPPY EVOLUTION", canvas.width/2, 200);
            ctx.font = "20px Courier New";
            ctx.fillText("Click or Space to Start", canvas.width/2, 240);
            ctx.fillText("Get 15 pts to Grow Legs!", canvas.width/2, 280);
        } else if (currentState === 'GAMEOVER') {
            ctx.fillStyle = 'rgba(0,0,0,0.5)';
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = '#FFF';
            ctx.textAlign = "center";
            ctx.font = "40px Courier New";
            ctx.fillText("GAME OVER", canvas.width/2, 200);
            ctx.font = "25px Courier New";
            ctx.fillText("Score: " + score, canvas.width/2, 250);
            ctx.font = "20px Courier New";
            ctx.fillText("Click to Restart", canvas.width/2, 300);
        } else if (currentState === 'WIN') {
            ctx.fillStyle = 'rgba(0,0,0,0.7)'; // Gold tint
            ctx.fillRect(0,0,canvas.width, canvas.height);
            ctx.fillStyle = '#FFD700';
            ctx.textAlign = "center";
            ctx.font = "40px Courier New";
            ctx.fillText("YOU WIN!", canvas.width/2, 200);
            ctx.fillStyle = '#FFF';
            ctx.font = "20px Courier New";
            ctx.fillText("Evolution Complete.", canvas.width/2, 250);
            ctx.fillText("Click to Play Again", canvas.width/2, 300);
        }
    }

    function loop() {
        // Clear Canvas
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        // Draw Background Elements
        ground.draw();

        if (currentState === 'FLAPPY') {
            pipes.update();
            pipes.draw();
            bird.update();
            frames++;
        } else if (currentState === 'RUNNER') {
            runnerBlocks.update();
            runnerBlocks.draw();
            bird.update();
            frames++;
        } else if (currentState === 'WIN') {
            bird.draw(); // Just draw the bird celebrating
        }

        bird.draw();
        
        // Foreground UI
        if (currentState !== 'START') {
            drawScore();
        }
        
        drawUI();

        requestAnimationFrame(loop);
    }

    // --- INPUT HANDLING ---

    function handleInput() {
        if (currentState === 'START') {
            currentState = 'FLAPPY';
        } else if (currentState === 'FLAPPY') {
            bird.flap();
        } else if (currentState === 'RUNNER') {
            bird.jump();
        } else if (currentState === 'GAMEOVER' || currentState === 'WIN') {
            resetGame();
        }
    }

    window.addEventListener('keydown', function(e) {
        if (e.code === 'Space') {
            handleInput();
        }
    });

    window.addEventListener('mousedown', function(e) {
        handleInput();
    });

    window.addEventListener('touchstart', function(e) {
        e.preventDefault(); // Prevent scrolling
        handleInput();
    }, {passive: false});

    // Start loop
    loop();

</script>
</body>
</html>

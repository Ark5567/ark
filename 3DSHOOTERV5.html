<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Shooter Game</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background: #000;
            font-family: 'Arial', sans-serif;
        }
        canvas {
            display: block;
        }
        body.locked {
            cursor: none;
        }
        #crosshair {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 20px;
            height: 20px;
            pointer-events: none;
            z-index: 10;
        }
        #crosshair::before,
        #crosshair::after {
            content: '';
            position: absolute;
            background: var(--crosshair-color, rgba(255, 255, 255, 0.9));
            box-shadow: 0 0 5px rgba(0,0,0,0.8);
        }
        #crosshair::before {
            width: 3px;
            height: 20px;
            left: 8.5px;
        }
        #crosshair::after {
            width: 20px;
            height: 3px;
            top: 8.5px;
        }
        #hud {
            position: absolute;
            top: 20px;
            left: 20px;
            color: white;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.8);
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 15px;
            border-radius: 10px;
        }
        #health {
            color: #ff6b6b;
            font-weight: bold;
            font-size: 24px;
        }
        #ammo {
            color: #ffe66d;
            font-weight: bold;
        }
        #score {
            color: #4ecdc4;
            font-weight: bold;
            font-size: 28px;
        }
        #wave {
            color: #a29bfe;
            font-weight: bold;
            font-size: 26px;
        }
        #currentGun {
            color: #74b9ff;
            font-weight: bold;
            font-size: 18px;
        }
        #bossBar {
            position: absolute;
            top: 50px;
            left: 50%;
            transform: translateX(-50%);
            width: 600px;
            display: none;
            z-index: 10;
        }
        #bossName {
            text-align: center;
            color: #ff6b6b;
            font-size: 32px;
            font-weight: bold;
            text-shadow: 0 0 20px #ff0000;
            margin-bottom: 10px;
        }
        #bossHealthBar {
            width: 100%;
            height: 30px;
            background: rgba(0,0,0,0.8);
            border: 3px solid #ff6b6b;
            border-radius: 15px;
            overflow: hidden;
            box-shadow: 0 0 20px rgba(255,0,0,0.5);
        }
        #bossHealthFill {
            height: 100%;
            width: 100%;
            background: linear-gradient(90deg, #ff0000, #ff6b6b);
            transition: width 0.3s;
            box-shadow: inset 0 0 20px rgba(255,255,255,0.3);
        }
        #waveComplete {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(109, 89, 234, 0.95);
            padding: 30px 50px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 3px solid #a29bfe;
            animation: pulse 0.5s ease-in-out;
        }
        @keyframes pulse {
            0%, 100% { transform: translate(-50%, -50%) scale(1); }
            50% { transform: translate(-50%, -50%) scale(1.1); }
        }
        #waveComplete h1 {
            color: white;
            font-size: 42px;
            margin: 0;
            text-shadow: 0 0 20px #fff;
        }
        #gameOver, #pauseMenu, #settingsMenu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.95);
            padding: 40px 60px;
            border-radius: 15px;
            text-align: center;
            display: none;
            z-index: 100;
            border: 2px solid #667eea;
        }
        #gameOver h1, #pauseMenu h1, #settingsMenu h1 {
            color: #ff6b6b;
            font-size: 48px;
            margin: 0 0 20px 0;
            text-shadow: 0 0 20px #ff6b6b;
        }
        #pauseMenu h1, #settingsMenu h1 {
            color: #667eea;
            text-shadow: 0 0 20px #667eea;
        }
        #gameOver p {
            color: white;
            font-size: 24px;
            margin: 10px 0;
        }
        .menu-button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            border: none;
            color: white;
            padding: 15px 40px;
            font-size: 20px;
            border-radius: 8px;
            cursor: pointer;
            margin: 10px;
            transition: all 0.3s;
            display: inline-block;
        }
        .menu-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(102, 126, 234, 0.6);
        }
        .menu-button.quit {
            background: linear-gradient(135deg, #ff6b6b 0%, #c92a2a 100%);
        }
        .setting-option {
            margin: 20px 0;
            color: white;
        }
        .color-option {
            display: inline-block;
            width: 40px;
            height: 40px;
            margin: 5px;
            border: 3px solid transparent;
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.3s;
        }
        .color-option:hover {
            transform: scale(1.2);
            border-color: white;
        }
        .color-option.selected {
            border-color: white;
            box-shadow: 0 0 15px rgba(255,255,255,0.8);
        }
        #instructions {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            color: white;
            background: rgba(0,0,0,0.7);
            padding: 15px 30px;
            border-radius: 10px;
            text-align: center;
            font-size: 14px;
        }
        .hit-marker {
            position: absolute;
            width: 40px;
            height: 40px;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.1s;
            z-index: 10;
        }
        .hit-marker::before,
        .hit-marker::after {
            content: '';
            position: absolute;
            background: #ff0000;
            box-shadow: 0 0 10px #ff0000;
        }
        .hit-marker::before {
            width: 40px;
            height: 4px;
            top: 50%;
            transform: translateY(-50%) rotate(45deg);
        }
        .hit-marker::after {
            width: 40px;
            height: 4px;
            top: 50%;
            transform: translateY(-50%) rotate(-45deg);
        }
    </style>
</head>
<body>
    <div id="crosshair"></div>
    <div class="hit-marker" id="hitMarker"></div>
    
    <div id="hud">
        <div id="wave">üåä Wave: <span id="waveValue">1</span></div>
        <div id="health">‚ù§Ô∏è Health: <span id="healthValue">100</span></div>
        <div id="ammo">üî´ Ammo: <span id="ammoValue">30</span></div>
        <div id="currentGun">Gun: <span id="gunName">Pistol</span></div>
        <div id="score">‚≠ê Score: <span id="scoreValue">0</span></div>
    </div>

    <div id="bossBar">
        <div id="bossName">üî• MEGA BOSS üî•</div>
        <div id="bossHealthBar">
            <div id="bossHealthFill"></div>
        </div>
    </div>

    <div id="waveComplete">
        <h1>WAVE <span id="completedWave">1</span> COMPLETE!</h1>
    </div>

    <div id="gameOver">
        <h1>GAME OVER</h1>
        <p>Final Score: <span id="finalScore">0</span></p>
        <p>Reached Wave: <span id="finalWave">1</span></p>
        <button class="menu-button" onclick="restartGame()">Play Again</button>
        <button class="menu-button quit" onclick="quitGame()">Quit</button>
    </div>

    <div id="pauseMenu">
        <h1>PAUSED</h1>
        <button class="menu-button" onclick="resumeGame()">Resume</button>
        <button class="menu-button" onclick="showSettings()">Settings</button>
        <button class="menu-button" onclick="restartGame()">Restart</button>
        <button class="menu-button quit" onclick="quitGame()">Quit to Menu</button>
    </div>

    <div id="settingsMenu">
        <h1>SETTINGS</h1>
        <div class="setting-option">
            <h3>Crosshair Color</h3>
            <div id="colorPicker"></div>
        </div>
        <button class="menu-button" onclick="backToPause()">Back</button>
    </div>

    <div id="instructions">
        WASD - Move | Mouse - Look | Click - Shoot | E - Pick up weapon | ESC - Menu
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, composer;
        let gun;
        let enemies = [];
        let enemyBullets = [];
        let weaponPickups = [];
        let collidableObjects = [];
        let windParticles, sunRays;
        let boss = null;
        let cameraShake = { x: 0, y: 0, intensity: 0 };
        let health = 100;
        let ammo = 30;
        let score = 0;
        let currentWave = 1;
        let enemiesInWave = 0;
        let enemiesKilled = 0;
        let gameActive = true;
        let isPaused = false;
        let isPointerLocked = false;
        let currentWeapon = { name: 'Pistol', damage: 1, ammo: 30, maxAmmo: 30, fireRate: 0 };
        
        const moveSpeed = 0.05;
        const enemySpeed = 0.01;
        const keys = {};
        let yaw = 0;
        let pitch = 0;

        const crosshairColors = {
            white: 'rgba(255, 255, 255, 0.9)',
            red: 'rgba(255, 0, 0, 0.9)',
            green: 'rgba(0, 255, 0, 0.9)',
            cyan: 'rgba(0, 255, 255, 0.9)',
            yellow: 'rgba(255, 255, 0, 0.9)',
            purple: 'rgba(255, 0, 255, 0.9)'
        };

        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x87ceeb);
            scene.fog = new THREE.FogExp2(0x87ceeb, 0.012);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 1.7, 5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.3;
            document.body.appendChild(renderer.domElement);

            const groundGeo = new THREE.PlaneGeometry(200, 200, 150, 150);
            const groundMat = new THREE.MeshStandardMaterial({ 
                color: 0x2d5016,
                roughness: 0.95,
                metalness: 0.05
            });
            const ground = new THREE.Mesh(groundGeo, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            
            const vertices = ground.geometry.attributes.position.array;
            for (let i = 0; i < vertices.length; i += 3) {
                vertices[i + 2] += (Math.random() - 0.5) * 0.4;
            }
            ground.geometry.attributes.position.needsUpdate = true;
            ground.geometry.computeVertexNormals();
            
            scene.add(ground);

            addGrass();
            createGun('Pistol');
            createSunRays();

            for (let i = 0; i < 50; i++) {
                createTree(
                    (Math.random() - 0.5) * 180,
                    (Math.random() - 0.5) * 180
                );
            }

            for (let i = 0; i < 40; i++) {
                createRock(
                    (Math.random() - 0.5) * 180,
                    (Math.random() - 0.5) * 180
                );
            }

            spawnWeaponPickups();
            createWindParticles();
            setupColorPicker();

            const ambientLight = new THREE.AmbientLight(0xffd9a0, 0.5);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffeaa7, 2);
            dirLight.position.set(100, 120, 80);
            dirLight.castShadow = true;
            dirLight.shadow.camera.left = -120;
            dirLight.shadow.camera.right = 120;
            dirLight.shadow.camera.top = 120;
            dirLight.shadow.camera.bottom = -120;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.bias = -0.00005;
            scene.add(dirLight);

            const hemiLight = new THREE.HemisphereLight(0x87ceeb, 0x1b5e20, 1);
            scene.add(hemiLight);

            const rimLight = new THREE.DirectionalLight(0xffa500, 0.8);
            rimLight.position.set(-50, 20, -50);
            scene.add(rimLight);

            startWave(1);

            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('click', onClick);
            document.addEventListener('pointerlockchange', onPointerLockChange);
            document.addEventListener('pointerlockerror', onPointerLockError);
            window.addEventListener('resize', onWindowResize);

            animate();
        }

        function setupColorPicker() {
            const picker = document.getElementById('colorPicker');
            Object.entries(crosshairColors).forEach(([name, color]) => {
                const div = document.createElement('div');
                div.className = 'color-option';
                div.style.background = color;
                if (name === 'white') div.classList.add('selected');
                div.onclick = () => changeCrosshairColor(name, color, div);
                picker.appendChild(div);
            });
        }

        function changeCrosshairColor(name, color, element) {
            document.querySelectorAll('.color-option').forEach(e => e.classList.remove('selected'));
            element.classList.add('selected');
            document.documentElement.style.setProperty('--crosshair-color', color);
        }

        function createSunRays() {
            const rayGeo = new THREE.CylinderGeometry(0.1, 1, 200, 8, 1, true);
            const rayMat = new THREE.MeshBasicMaterial({
                color: 0xffeaa7,
                transparent: true,
                opacity: 0.15,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending
            });

            for (let i = 0; i < 20; i++) {
                const ray = new THREE.Mesh(rayGeo, rayMat);
                ray.position.set(80 + Math.random() * 40, 100, 60 + Math.random() * 40);
                ray.rotation.z = Math.random() * 0.3 - 0.15;
                ray.rotation.x = Math.PI / 6;
                scene.add(ray);
            }
        }

        function spawnWeaponPickups() {
            const weapons = [
                { name: 'Rifle', damage: 1, ammo: 90, maxAmmo: 90, color: 0x4a4a4a },
                { name: 'Shotgun', damage: 3, ammo: 20, maxAmmo: 20, color: 0x8b4513 },
                { name: 'SMG', damage: 1, ammo: 120, maxAmmo: 120, color: 0x2c3e50 }
            ];

            weapons.forEach(weapon => {
                for (let i = 0; i < 3; i++) {
                    const pickup = new THREE.Group();
                    const geo = new THREE.BoxGeometry(0.6, 0.3, 0.15);
                    const mat = new THREE.MeshStandardMaterial({ 
                        color: weapon.color,
                        emissive: weapon.color,
                        emissiveIntensity: 0.3,
                        metalness: 0.8,
                        roughness: 0.2
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    pickup.add(mesh);

                    pickup.position.set(
                        (Math.random() - 0.5) * 100,
                        0.5,
                        (Math.random() - 0.5) * 100
                    );
                    pickup.weaponData = { ...weapon };
                    pickup.bobOffset = Math.random() * Math.PI * 2;
                    
                    scene.add(pickup);
                    weaponPickups.push(pickup);
                }
            });
        }

        function addGrass() {
            const grassCount = 8000;
            const grassGeo = new THREE.PlaneGeometry(0.25, 0.6);
            const grassMat = new THREE.MeshStandardMaterial({ 
                color: 0x1b5e20,
                side: THREE.DoubleSide,
                roughness: 0.95
            });

            for (let i = 0; i < grassCount; i++) {
                const grass = new THREE.Mesh(grassGeo, grassMat);
                grass.position.x = (Math.random() - 0.5) * 190;
                grass.position.z = (Math.random() - 0.5) * 190;
                grass.position.y = 0.3;
                grass.rotation.y = Math.random() * Math.PI;
                grass.rotation.x = Math.PI / 2 + (Math.random() - 0.5) * 0.4;
                scene.add(grass);
            }
        }

        function createWindParticles() {
            const particleCount = 800;
            const positions = new Float32Array(particleCount * 3);
            const velocities = [];

            for (let i = 0; i < particleCount; i++) {
                positions[i * 3] = (Math.random() - 0.5) * 250;
                positions[i * 3 + 1] = Math.random() * 40 + 2;
                positions[i * 3 + 2] = (Math.random() - 0.5) * 250;
                
                velocities.push({
                    x: Math.random() * 0.12 + 0.06,
                    y: (Math.random() - 0.5) * 0.03,
                    z: (Math.random() - 0.5) * 0.06
                });
            }

            const particleGeo = new THREE.BufferGeometry();
            particleGeo.setAttribute('position', new THREE.BufferAttribute(positions, 3));

            const particleMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.12,
                transparent: true,
                opacity: 0.5,
                blending: THREE.AdditiveBlending
            });

            windParticles = new THREE.Points(particleGeo, particleMat);
            windParticles.velocities = velocities;
            scene.add(windParticles);
        }

        function updateWindParticles() {
            const positions = windParticles.geometry.attributes.position.array;
            
            for (let i = 0; i < windParticles.velocities.length; i++) {
                positions[i * 3] += windParticles.velocities[i].x;
                positions[i * 3 + 1] += windParticles.velocities[i].y;
                positions[i * 3 + 2] += windParticles.velocities[i].z;

                if (positions[i * 3] > 125) positions[i * 3] = -125;
                if (positions[i * 3] < -125) positions[i * 3] = 125;
                if (positions[i * 3 + 1] > 42) positions[i * 3 + 1] = 2;
                if (positions[i * 3 + 1] < 2) positions[i * 3 + 1] = 42;
            }
            
            windParticles.geometry.attributes.position.needsUpdate = true;
        }

        function startWave(wave) {
            currentWave = wave;
            
            if (wave === 10) {
                spawnBoss();
                return;
            }
            
            enemiesInWave = 3 + (wave * 2);
            enemiesKilled = 0;
            document.getElementById('waveValue').textContent = wave;

            const shooterCount = wave >= 5 ? Math.floor(enemiesInWave * 0.4) : 0;
            
            for (let i = 0; i < enemiesInWave; i++) {
                setTimeout(() => {
                    if (gameActive) {
                        const isShooter = i < shooterCount;
                        spawnEnemy(isShooter);
                    }
                }, i * 1000);
            }
        }

        function spawnBoss() {
            document.getElementById('bossBar').style.display = 'block';
            
            boss = createBoss();
            boss.position.set(0, -10, -40);
            boss.health = 50;
            boss.maxHealth = 50;
            boss.speed = 0.003;
            boss.walkCycle = 0;
            boss.attackCooldown = 0;
            
            scene.add(boss);
            enemies.push(boss);

            let spawnTime = 0;
            const spawnInterval = setInterval(() => {
                spawnTime++;
                boss.position.y = -10 + (spawnTime / 80) * 10;
                
                if (spawnTime === 80) {
                    cameraShake.intensity = 1;
                    setTimeout(() => cameraShake.intensity = 0, 500);
                }
                
                if (spawnTime >= 100) {
                    clearInterval(spawnInterval);
                    boss.position.y = 0;
                }
            }, 16);
        }

        function createBoss() {
            const boss = new THREE.Group();
            
            const headGeo = new THREE.SphereGeometry(0.8, 16, 16);
            const skinMat = new THREE.MeshStandardMaterial({ 
                color: 0xaa0000,
                emissive: 0x660000,
                emissiveIntensity: 0.8,
                roughness: 0.3,
                metalness: 0.5
            });
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 5;
            head.castShadow = true;
            boss.add(head);

            const neckGeo = new THREE.CylinderGeometry(0.35, 0.35, 0.6, 12);
            const neck = new THREE.Mesh(neckGeo, skinMat);
            neck.position.y = 4.3;
            neck.castShadow = true;
            boss.add(neck);

            const torsoGeo = new THREE.BoxGeometry(1.8, 2.5, 1.2);
            const torso = new THREE.Mesh(torsoGeo, skinMat);
            torso.position.y = 2.75;
            torso.castShadow = true;
            boss.add(torso);

            const waistGeo = new THREE.BoxGeometry(1.6, 0.7, 1.1);
            const waist = new THREE.Mesh(waistGeo, skinMat);
            waist.position.y = 1.25;
            waist.castShadow = true;
            boss.add(waist);

            const legGeo = new THREE.CylinderGeometry(0.3, 0.35, 1.5, 12);
            const leftThigh = new THREE.Mesh(legGeo, skinMat);
            leftThigh.position.set(-0.4, 0.5, 0);
            leftThigh.castShadow = true;
            boss.add(leftThigh);

            const rightThigh = new THREE.Mesh(legGeo, skinMat);
            rightThigh.position.set(0.4, 0.5, 0);
            rightThigh.castShadow = true;
            boss.add(rightThigh);

            const calfGeo = new THREE.CylinderGeometry(0.25, 0.3, 1.3, 12);
            const leftCalf = new THREE.Mesh(calfGeo, skinMat);
            leftCalf.position.set(-0.4, -0.65, 0);
            leftCalf.castShadow = true;
            boss.add(leftCalf);

            const rightCalf = new THREE.Mesh(calfGeo, skinMat);
            rightCalf.position.set(0.4, -0.65, 0);
            rightCalf.castShadow = true;
            boss.add(rightCalf);

            const armGeo = new THREE.CylinderGeometry(0.25, 0.3, 1.5, 12);
            const leftShoulder = new THREE.Mesh(armGeo, skinMat);
            leftShoulder.position.set(-1.1, 3.2, 0);
            leftShoulder.castShadow = true;
            boss.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(armGeo, skinMat);
            rightShoulder.position.set(1.1, 3.2, 0);
            rightShoulder.castShadow = true;
            boss.add(rightShoulder);

            const forearmGeo = new THREE.CylinderGeometry(0.22, 0.28, 1.4, 12);
            const leftForearm = new THREE.Mesh(forearmGeo, skinMat);
            leftForearm.position.set(-1.1, 1.8, 0);
            leftForearm.castShadow = true;
            boss.add(leftForearm);

            const rightForearm = new THREE.Mesh(forearmGeo, skinMat);
            rightForearm.position.set(1.1, 1.8, 0);
            rightForearm.castShadow = true;
            boss.add(rightForearm);

            boss.leftThigh = leftThigh;
            boss.rightThigh = rightThigh;
            boss.leftCalf = leftCalf;
            boss.rightCalf = rightCalf;
            boss.leftShoulder = leftShoulder;
            boss.rightShoulder = rightShoulder;
            boss.leftForearm = leftForearm;
            boss.rightForearm = rightForearm;
            boss.isBoss = true;

            return boss;
        }

        function updateBossBar() {
            if (boss && boss.health > 0) {
                const percent = (boss.health / boss.maxHealth) * 100;
                document.getElementById('bossHealthFill').style.width = percent + '%';
            }
        }

        function onEnemyKilled() {
            enemiesKilled++;
            
            if (currentWave === 10 && boss && boss.health <= 0) {
                document.getElementById('bossBar').style.display = 'none';
                setTimeout(() => {
                    showWaveComplete();
                }, 1000);
            } else if (enemiesKilled >= enemiesInWave && currentWave !== 10) {
                setTimeout(() => {
                    showWaveComplete();
                }, 500);
            }
        }

        function showWaveComplete() {
            document.getElementById('completedWave').textContent = currentWave;
            document.getElementById('waveComplete').style.display = 'block';
            
            setTimeout(() => {
                document.getElementById('waveComplete').style.display = 'none';
                startWave(currentWave + 1);
            }, 2000);
        }

        function showSettings() {
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('settingsMenu').style.display = 'block';
        }

        function backToPause() {
            document.getElementById('settingsMenu').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'block';
        }

        function onClick() {
            if (!isPaused && gameActive) {
                if (!isPointerLocked) {
                    renderer.domElement.requestPointerLock();
                } else {
                    shoot();
                }
            }
        }

        function onPointerLockChange() {
            isPointerLocked = document.pointerLockElement === renderer.domElement;
            
            if (isPointerLocked) {
                document.body.classList.add('locked');
                document.addEventListener('mousemove', onMouseMove);
            } else {
                document.body.classList.remove('locked');
                document.removeEventListener('mousemove', onMouseMove);
            }
        }

        function onPointerLockError() {
            console.error('Pointer lock error');
        }

        function onKeyDown(e) {
            keys[e.key.toLowerCase()] = true;
            
            if (e.key === 'Escape') {
                e.preventDefault();
                if (gameActive && document.getElementById('gameOver').style.display !== 'block') {
                    togglePause();
                }
            }
            
            if (e.key.toLowerCase() === 'e') {
                checkWeaponPickup();
            }
        }

        function onKeyUp(e) {
            keys[e.key.toLowerCase()] = false;
        }

        function checkWeaponPickup() {
            weaponPickups.forEach((pickup, index) => {
                const dist = camera.position.distanceTo(pickup.position);
                if (dist < 3) {
                    pickupWeapon(pickup.weaponData);
                    scene.remove(pickup);
                    weaponPickups.splice(index, 1);
                }
            });
        }

        function pickupWeapon(weaponData) {
            currentWeapon = { ...weaponData };
            ammo = weaponData.maxAmmo;
            document.getElementById('ammoValue').textContent = ammo;
            document.getElementById('gunName').textContent = weaponData.name;
            
            camera.remove(gun);
            createGun(weaponData.name);
        }

        function togglePause() {
            isPaused = !isPaused;
            const pauseMenu = document.getElementById('pauseMenu');
            
            if (isPaused) {
                pauseMenu.style.display = 'block';
                document.exitPointerLock();
            } else {
                pauseMenu.style.display = 'none';
                renderer.domElement.requestPointerLock();
            }
        }

        function resumeGame() {
            isPaused = false;
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('settingsMenu').style.display = 'none';
            renderer.domElement.requestPointerLock();
        }

        function quitGame() {
            window.location.reload();
        }

        function createGun(type) {
            if (gun) camera.remove(gun);
            gun = new THREE.Group();

            if (type === 'Rifle') {
                const barrelGeo = new THREE.CylinderGeometry(0.035, 0.035, 1.4, 16);
                const barrelMat = new THREE.MeshStandardMaterial({ 
                    color: 0x2a2a2a,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(0.6, -0.35, -0.7);
                gun.add(barrel);

                const bodyGeo = new THREE.BoxGeometry(0.2, 0.2, 0.5);
                const body = new THREE.Mesh(bodyGeo, barrelMat);
                body.position.set(0.1, -0.35, -0.6);
                gun.add(body);
            } else if (type === 'Shotgun') {
                const barrelGeo = new THREE.CylinderGeometry(0.06, 0.06, 1, 8);
                const barrelMat = new THREE.MeshStandardMaterial({ 
                    color: 0x4a2511,
                    metalness: 0.8,
                    roughness: 0.3
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(0.45, -0.3, -0.55);
                gun.add(barrel);

                const bodyGeo = new THREE.BoxGeometry(0.2, 0.2, 0.4);
                const body = new THREE.Mesh(bodyGeo, barrelMat);
                body.position.set(0.15, -0.3, -0.5);
                gun.add(body);
            } else if (type === 'SMG') {
                const barrelGeo = new THREE.CylinderGeometry(0.03, 0.03, 0.7, 16);
                const barrelMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.9,
                    roughness: 0.2
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(0.4, -0.4, -0.5);
                gun.add(barrel);

                const bodyGeo = new THREE.BoxGeometry(0.15, 0.25, 0.3);
                const body = new THREE.Mesh(bodyGeo, barrelMat);
                body.position.set(0.15, -0.35, -0.45);
                gun.add(body);
            } else {
                const barrelGeo = new THREE.CylinderGeometry(0.04, 0.04, 1, 16);
                const barrelMat = new THREE.MeshStandardMaterial({ 
                    color: 0x111111,
                    metalness: 0.9,
                    roughness: 0.1
                });
                const barrel = new THREE.Mesh(barrelGeo, barrelMat);
                barrel.rotation.z = Math.PI / 2;
                barrel.position.set(0.5, -0.35, -0.6);
                gun.add(barrel);

                const bodyGeo = new THREE.BoxGeometry(0.18, 0.18, 0.35);
                const bodyMat = new THREE.MeshStandardMaterial({ 
                    color: 0x1a1a1a,
                    metalness: 0.7,
                    roughness: 0.3
                });
                const body = new THREE.Mesh(bodyGeo, bodyMat);
                body.position.set(0.2, -0.35, -0.5);
                gun.add(body);

                const gripGeo = new THREE.BoxGeometry(0.1, 0.25, 0.14);
                const gripMat = new THREE.MeshStandardMaterial({ 
                    color: 0x5d4037,
                    roughness: 0.95,
                    metalness: 0
                });
                const grip = new THREE.Mesh(gripGeo, gripMat);
                grip.position.set(0.2, -0.52, -0.5);
                gun.add(grip);
            }

            camera.add(gun);
            scene.add(camera);
        }

        function createTree(x, z) {
            const tree = new THREE.Group();

            const trunkGeo = new THREE.CylinderGeometry(0.45, 0.55, 5, 6);
            const trunkMat = new THREE.MeshStandardMaterial({ 
                color: 0x3e2723,
                roughness: 0.95,
                metalness: 0,
                flatShading: true
            });
            const trunk = new THREE.Mesh(trunkGeo, trunkMat);
            trunk.position.y = 2.5;
            trunk.castShadow = true;
            trunk.receiveShadow = true;
            tree.add(trunk);

            const leavesGeo = new THREE.ConeGeometry(2.2, 4.5, 6);
            const leavesMat = new THREE.MeshStandardMaterial({ 
                color: 0x1b5e20,
                roughness: 0.9,
                metalness: 0,
                flatShading: true
            });
            const leaves = new THREE.Mesh(leavesGeo, leavesMat);
            leaves.position.y = 6;
            leaves.castShadow = true;
            leaves.receiveShadow = true;
            tree.add(leaves);

            tree.position.set(x, 0, z);
            scene.add(tree);
            
            const collider = new THREE.Mesh(
                new THREE.CylinderGeometry(0.7, 0.8, 5, 8),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            collider.position.copy(tree.position);
            collider.position.y = 2.5;
            collidableObjects.push(collider);
        }

        function createRock(x, z) {
            const size = 0.7 + Math.random() * 1.4;
            const rockGeo = new THREE.DodecahedronGeometry(size, 0);
            const rockMat = new THREE.MeshStandardMaterial({ 
                color: 0x616161,
                roughness: 0.95,
                metalness: 0.05,
                flatShading: true
            });
            const rock = new THREE.Mesh(rockGeo, rockMat);
            rock.position.set(x, size / 2, z);
            rock.rotation.set(
                Math.random() * Math.PI,
                Math.random() * Math.PI,
                Math.random() * Math.PI
            );
            rock.castShadow = true;
            rock.receiveShadow = true;
            scene.add(rock);
            
            const collider = new THREE.Mesh(
                new THREE.SphereGeometry(size * 1.3),
                new THREE.MeshBasicMaterial({ visible: false })
            );
            collider.position.copy(rock.position);
            collidableObjects.push(collider);
        }

        function createHumanoid(isShooter = false) {
            const humanoid = new THREE.Group();
            
            const color = isShooter ? 0x0000cc : 0xcc0000;
            const emissive = isShooter ? 0x000088 : 0x880000;

            const headGeo = new THREE.SphereGeometry(0.25, 16, 16);
            const skinMat = new THREE.MeshStandardMaterial({ 
                color: color,
                emissive: emissive,
                emissiveIntensity: 0.5,
                roughness: 0.4,
                metalness: 0.3
            });
            const head = new THREE.Mesh(headGeo, skinMat);
            head.position.y = 1.65;
            head.castShadow = true;
            humanoid.add(head);

            const neckGeo = new THREE.CylinderGeometry(0.1, 0.1, 0.15, 8);
            const neck = new THREE.Mesh(neckGeo, skinMat);
            neck.position.y = 1.45;
            neck.castShadow = true;
            humanoid.add(neck);

            const torsoGeo = new THREE.BoxGeometry(0.5, 0.7, 0.3);
            const torso = new THREE.Mesh(torsoGeo, skinMat);
            torso.position.y = 1;
            torso.castShadow = true;
            humanoid.add(torso);

            const waistGeo = new THREE.BoxGeometry(0.45, 0.2, 0.28);
            const waist = new THREE.Mesh(waistGeo, skinMat);
            waist.position.y = 0.55;
            waist.castShadow = true;
            humanoid.add(waist);

            const legGeo = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 12);
            const leftThigh = new THREE.Mesh(legGeo, skinMat);
            leftThigh.position.set(-0.12, 0.25, 0);
            leftThigh.castShadow = true;
            humanoid.add(leftThigh);

            const rightThigh = new THREE.Mesh(legGeo, skinMat);
            rightThigh.position.set(0.12, 0.25, 0);
            rightThigh.castShadow = true;
            humanoid.add(rightThigh);

            const calfGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.45, 12);
            const leftCalf = new THREE.Mesh(calfGeo, skinMat);
            leftCalf.position.set(-0.12, -0.225, 0);
            leftCalf.castShadow = true;
            humanoid.add(leftCalf);

            const rightCalf = new THREE.Mesh(calfGeo, skinMat);
            rightCalf.position.set(0.12, -0.225, 0);
            rightCalf.castShadow = true;
            humanoid.add(rightCalf);

            const armGeo = new THREE.CylinderGeometry(0.07, 0.08, 0.45, 12);
            const leftShoulder = new THREE.Mesh(armGeo, skinMat);
            leftShoulder.position.set(-0.32, 1.15, 0);
            leftShoulder.castShadow = true;
            humanoid.add(leftShoulder);

            const rightShoulder = new THREE.Mesh(armGeo, skinMat);
            rightShoulder.position.set(0.32, 1.15, 0);
            rightShoulder.castShadow = true;
            humanoid.add(rightShoulder);

            const forearmGeo = new THREE.CylinderGeometry(0.06, 0.07, 0.4, 12);
            const leftForearm = new THREE.Mesh(forearmGeo, skinMat);
            leftForearm.position.set(-0.32, 0.7, 0);
            leftForearm.castShadow = true;
            humanoid.add(leftForearm);

            const rightForearm = new THREE.Mesh(forearmGeo, skinMat);
            rightForearm.position.set(0.32, 0.7, 0);
            rightForearm.castShadow = true;
            humanoid.add(rightForearm);

            humanoid.leftThigh = leftThigh;
            humanoid.rightThigh = rightThigh;
            humanoid.leftCalf = leftCalf;
            humanoid.rightCalf = rightCalf;
            humanoid.leftShoulder = leftShoulder;
            humanoid.rightShoulder = rightShoulder;
            humanoid.leftForearm = leftForearm;
            humanoid.rightForearm = rightForearm;

            return humanoid;
        }

        function spawnEnemy(isShooter = false) {
            const enemy = createHumanoid(isShooter);
            
            const angle = Math.random() * Math.PI * 2;
            const distance = 25 + Math.random() * 40;
            enemy.position.x = Math.cos(angle) * distance;
            enemy.position.y = 0;
            enemy.position.z = Math.sin(angle) * distance;
            
            enemy.health = isShooter ? 5 : 3;
            enemy.maxHealth = enemy.health;
            enemy.speed = enemySpeed;
            enemy.walkCycle = 0;
            enemy.isShooter = isShooter;
            enemy.shootCooldown = 0;
            enemy.accuracy = 0.35;
            
            scene.add(enemy);
            enemies.push(enemy);
        }

        function shoot() {
            if (!gameActive || ammo <= 0 || isPaused) return;
            
            ammo--;
            document.getElementById('ammoValue').textContent = ammo;
            
            gun.position.z += 0.15;
            setTimeout(() => gun.position.z = 0, 80);
            
            const direction = new THREE.Vector3();
            camera.getWorldDirection(direction);
            
            const raycaster = new THREE.Raycaster(camera.position, direction, 0, 150);
            const intersects = raycaster.intersectObjects(scene.children, true);
            
            for (let i = 0; i < intersects.length; i++) {
                let object = intersects[i].object;
                
                while (object.parent && object.parent !== scene) {
                    object = object.parent;
                    if (enemies.includes(object)) {
                        hitEnemy(object);
                        return;
                    }
                }
            }
            
            if (ammo === 0) {
                setTimeout(() => {
                    if (gameActive) {
                        ammo = currentWeapon.maxAmmo;
                        document.getElementById('ammoValue').textContent = ammo;
                    }
                }, 1500);
            }
        }

        function enemyShoot(enemy) {
            const bulletGeo = new THREE.SphereGeometry(0.1, 8, 8);
            const bulletMat = new THREE.MeshBasicMaterial({ 
                color: 0x0000ff,
                emissive: 0x0000ff
            });
            const bullet = new THREE.Mesh(bulletGeo, bulletMat);
            
            bullet.position.copy(enemy.position);
            bullet.position.y += 1.5;
            
            const direction = new THREE.Vector3();
            direction.subVectors(camera.position, enemy.position);
            direction.normalize();
            
            const accuracy = enemy.accuracy;
            direction.x += (Math.random() - 0.5) * (1 - accuracy) * 2;
            direction.y += (Math.random() - 0.5) * (1 - accuracy) * 2;
            direction.z += (Math.random() - 0.5) * (1 - accuracy) * 2;
            direction.normalize();
            
            bullet.velocity = direction.multiplyScalar(0.3);
            bullet.life = 0;
            
            scene.add(bullet);
            enemyBullets.push(bullet);
        }

        function updateEnemyBullets() {
            for (let i = enemyBullets.length - 1; i >= 0; i--) {
                const bullet = enemyBullets[i];
                bullet.position.add(bullet.velocity);
                bullet.life++;
                
                const distToPlayer = bullet.position.distanceTo(camera.position);
                if (distToPlayer < 1) {
                    health -= 10;
                    document.getElementById('healthValue').textContent = Math.max(0, Math.floor(health));
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                    
                    if (health <= 0) {
                        gameOver();
                    }
                    continue;
                }
                
                if (bullet.life > 150) {
                    scene.remove(bullet);
                    enemyBullets.splice(i, 1);
                }
            }
        }

        function hitEnemy(enemy) {
            if (!enemy.health) return;
            
            enemy.health -= currentWeapon.damage;
            
            const hitMarker = document.getElementById('hitMarker');
            hitMarker.style.opacity = '1';
            setTimeout(() => hitMarker.style.opacity = '0', 150);
            
            enemy.children.forEach(child => {
                if (child.material) {
                    const originalIntensity = child.material.emissiveIntensity;
                    child.material.emissiveIntensity = 2;
                    setTimeout(() => child.material.emissiveIntensity = originalIntensity, 100);
                }
            });
            
            if (enemy.isBoss) {
                updateBossBar();
            }
            
            if (enemy.health <= 0) {
                let fallTime = 0;
                const fallInterval = setInterval(() => {
                    fallTime++;
                    enemy.position.y -= 0.03;
                    enemy.rotation.x += 0.08;
                    enemy.rotation.z += 0.05;
                    
                    if (fallTime > 80) {
                        clearInterval(fallInterval);
                        scene.remove(enemy);
                        const index = enemies.indexOf(enemy);
                        if (index > -1) {
                            enemies.splice(index, 1);
                        }
                        if (enemy.isBoss) {
                            boss = null;
                        }
                        onEnemyKilled();
                    }
                }, 20);
                
                score += enemy.isBoss ? 100 : (enemy.isShooter ? 20 : 10);
                document.getElementById('scoreValue').textContent = score;
            }
        }

        function onMouseMove(event) {
            if (!isPointerLocked || isPaused) return;
            
            yaw -= event.movementX * 0.002;
            pitch -= event.movementY * 0.002;
            pitch = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, pitch));
        }

        function checkCollision(newPos) {
            const playerRadius = 0.5;
            
            for (const obj of collidableObjects) {
                const distance = new THREE.Vector2(
                    newPos.x - obj.position.x,
                    newPos.z - obj.position.z
                ).length();
                
                if (distance < playerRadius + 0.7) {
                    return true;
                }
            }
            return false;
        }

        function updateCamera() {
            if (!gameActive || isPaused) return;
            
            if (cameraShake.intensity > 0) {
                cameraShake.x = (Math.random() - 0.5) * cameraShake.intensity * 0.1;
                cameraShake.y = (Math.random() - 0.5) * cameraShake.intensity * 0.1;
                cameraShake.intensity *= 0.9;
            } else {
                cameraShake.x = 0;
                cameraShake.y = 0;
            }
            
            camera.rotation.order = 'YXZ';
            camera.rotation.y = yaw + cameraShake.x;
            camera.rotation.x = pitch + cameraShake.y;

            const forward = new THREE.Vector3(0, 0, -1);
            forward.applyQuaternion(camera.quaternion);
            forward.y = 0;
            forward.normalize();

            const right = new THREE.Vector3(1, 0, 0);
            right.applyQuaternion(camera.quaternion);
            right.y = 0;
            right.normalize();
            
            const newPos = camera.position.clone();
            
            if (keys['w']) {
                newPos.add(forward.clone().multiplyScalar(moveSpeed));
                if (!checkCollision(newPos)) {
                    camera.position.copy(newPos);
                }
            }
            if (keys['s']) {
                newPos.copy(camera.position);
                newPos.sub(forward.clone().multiplyScalar(moveSpeed));
                if (!checkCollision(newPos)) {
                    camera.position.copy(newPos);
                }
            }
            if (keys['a']) {
                newPos.copy(camera.position);
                newPos.sub(right.clone().multiplyScalar(moveSpeed));
                if (!checkCollision(newPos)) {
                    camera.position.copy(newPos);
                }
            }
            if (keys['d']) {
                newPos.copy(camera.position);
                newPos.add(right.clone().multiplyScalar(moveSpeed));
                if (!checkCollision(newPos)) {
                    camera.position.copy(newPos);
                }
            }

            camera.position.y = 1.7;
        }

        function updateWeaponPickups() {
            weaponPickups.forEach(pickup => {
                pickup.rotation.y += 0.02;
                pickup.position.y = 0.5 + Math.sin(Date.now() * 0.002 + pickup.bobOffset) * 0.15;
            });
        }

        function updateEnemies() {
            if (isPaused) return;
            
            enemies.forEach(enemy => {
                const direction = new THREE.Vector3();
                direction.subVectors(camera.position, enemy.position);
                direction.y = 0;
                const distance = direction.length();
                direction.normalize();
                
                if (enemy.isBoss) {
                    enemy.position.add(direction.multiplyScalar(enemy.speed));
                    
                    if (distance < 5) {
                        health -= 0.5;
                        document.getElementById('healthValue').textContent = Math.max(0, Math.floor(health));
                        cameraShake.intensity = 0.5;
                        
                        if (health <= 0) {
                            gameOver();
                        }
                    }
                } else if (enemy.isShooter && distance > 15) {
                    enemy.position.add(direction.multiplyScalar(enemy.speed));
                } else if (enemy.isShooter) {
                    enemy.shootCooldown--;
                    if (enemy.shootCooldown <= 0) {
                        enemyShoot(enemy);
                        enemy.shootCooldown = 120;
                    }
                } else {
                    enemy.position.add(direction.multiplyScalar(enemy.speed));
                }
                
                const targetRotation = Math.atan2(direction.x, direction.z);
                enemy.rotation.y = targetRotation;
                
                enemy.walkCycle += 0.15;
                const swing = Math.sin(enemy.walkCycle);
                
                if (enemy.leftThigh) {
                    enemy.leftThigh.rotation.x = swing * 0.6;
                    enemy.rightThigh.rotation.x = -swing * 0.6;
                    enemy.leftCalf.rotation.x = Math.max(0, swing * 0.5);
                    enemy.rightCalf.rotation.x = Math.max(0, -swing * 0.5);
                    enemy.leftShoulder.rotation.x = -swing * 0.5;
                    enemy.rightShoulder.rotation.x = swing * 0.5;
                    enemy.leftForearm.rotation.x = -swing * 0.3;
                    enemy.rightForearm.rotation.x = swing * 0.3;
                }
                
                if (distance < 2 && !enemy.isBoss) {
                    health -= 0.2;
                    document.getElementById('healthValue').textContent = Math.max(0, Math.floor(health));
                    
                    if (health <= 0) {
                        gameOver();
                    }
                }
            });
        }

        function gameOver() {
            gameActive = false;
            document.exitPointerLock();
            document.getElementById('finalScore').textContent = score;
            document.getElementById('finalWave').textContent = currentWave;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            enemies.forEach(e => scene.remove(e));
            enemyBullets.forEach(b => scene.remove(b));
            weaponPickups.forEach(w => scene.remove(w));
            enemies = [];
            enemyBullets = [];
            weaponPickups = [];
            boss = null;
            
            health = 100;
            currentWeapon = { name: 'Pistol', damage: 1, ammo: 30, maxAmmo: 30 };
            ammo = 30;
            score = 0;
            currentWave = 1;
            enemiesInWave = 0;
            enemiesKilled = 0;
            gameActive = true;
            isPaused = false;
            yaw = 0;
            pitch = 0;
            cameraShake = { x: 0, y: 0, intensity: 0 };
            
            document.getElementById('healthValue').textContent = health;
            document.getElementById('ammoValue').textContent = ammo;
            document.getElementById('scoreValue').textContent = score;
            document.getElementById('waveValue').textContent = 1;
            document.getElementById('gunName').textContent = 'Pistol';
            document.getElementById('gameOver').style.display = 'none';
            document.getElementById('pauseMenu').style.display = 'none';
            document.getElementById('settingsMenu').style.display = 'none';
            document.getElementById('waveComplete').style.display = 'none';
            document.getElementById('bossBar').style.display = 'none';
            
            camera.position.set(0, 1.7, 5);
            camera.rotation.set(0, 0, 0);
            
            spawnWeaponPickups();
            startWave(1);
            
            renderer.domElement.requestPointerLock();
        }

        function animate() {
            requestAnimationFrame(animate);
            
            if (gameActive && !isPaused) {
                updateCamera();
                updateEnemies();
                updateEnemyBullets();
                updateWindParticles();
                updateWeaponPickups();
            }
            
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        init();
    </script>
</body>
</html>